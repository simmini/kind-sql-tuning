## 4.4.1 서브쿼리 변환이 필요한 이유

### 핵심 개념 정리

**옵티마이저의 실행계획 수립 방식과 한계**
옵티마이저는 주어진 쿼리에 대해 가장 비용이 적게 드는 실행 계획을 선택함. 이를 위해 조인 순서, 조인 방식, 액세스 경로 등을 다각도로 고려하며, 이때 개발자가 작성한 SQL의 형태가 옵티마이저의 선택 폭을 크게 좌우함.

**서브쿼리가 옵티마이저를 방해하는 경우**

  - **독립적인 처리 단위**: 서브쿼리는 종종 독립적인 처리 단위로 인식되어, 옵티마이저가 메인 쿼리와의 관계를 통합적으로 최적화하는 데 방해가 됨.
  - **최적의 조인 순서 제한**: 옵티마이저는 서브쿼리를 먼저 수행한 후 그 결과집합과 다른 테이블을 조인하는, 비효율적인 순서를 강요받을 수 있음.
  - **최적의 액세스 경로 제한**: 서브쿼리 내의 테이블에 대한 최적의 인덱스 활용이 불가능해질 수 있음.

#### 서브쿼리를 조인으로 변환해야 하는 근본적인 이유

서브쿼리라는 '틀'을 제거하고 **일반적인 조인(JOIN) 구문으로 풀어주면**, 옵티마이저가 가진 모든 최적화 기능(통계정보 기반의 비용 계산, 조인 순서 결정 등)을 100% 활용할 수 있게 됨. 이로써 더 나은 실행 계획을 찾을 가능성이 커짐. 즉, 옵티마이저에게 **더 많은 선택의 자유**를 부여하기 위함임.

## 4.4.2 서브쿼리와 조인

### 서브쿼리 Unnesting (Subquery Unnesting)

#### 정의

옵티마이저가 FROM 절에 사용된 서브쿼리(인라인 뷰)를 풀어내어, 서브쿼리 내의 테이블들을 메인 쿼리의 테이블들과 직접 조인하도록 SQL을 내부적으로 재작성하는 최적화 기법임.

#### Unnesting 과정

1.  **서브쿼리 확인**: 옵티마이저가 FROM 절의 서브쿼리를 인지함.
2.  **비용 분석**: 서브쿼리를 그대로 실행(No-Unnesting)하는 비용과, 서브쿼리를 풀어내어 다른 테이블과 조인(Unnesting)하는 비용을 비교함.
3.  **변환 수행**: Unnesting 방식의 비용이 더 낮다고 판단되면, 서브쿼리의 조인 조건과 필터 조건을 메인 쿼리로 통합하여 실행 계획을 수립함.

#### Unnesting을 통한 성능 개선

  - **최적의 조인 순서 선택**: 어떤 테이블을 먼저 읽을지 옵티마이저가 자유롭게 결정할 수 있음.
  - **다양한 조인 방식 적용**: NL Join, Hash Join, Sort Merge Join 등 가장 효율적인 조인 방식을 선택할 수 있음.

#### Unnesting 방해 요소

아래와 같은 요소가 서브쿼리에 포함되면 옵티마이저는 Unnesting을 포기하고, 서브쿼리 결과집합을 먼저 생성(Materialize)하는 방식을 택할 가능성이 높음.

  - `ROWNUM` 유사 컬럼
  - 집계 함수 (`COUNT`, `SUM` 등)
  - 분석 함수 (`ROW_NUMBER`, `RANK` 등)
  - `UNION`, `MINUS` 등 집합 연산자

## 4.4.3 뷰(View)와 조인

### 뷰 머징 (View Merging)

#### 정의

옵티마이저가 쿼리에서 사용된 뷰(View)의 정의(SQL 텍스트)를 메인 쿼리에 통합하여 하나의 쿼리로 재작성한 후 최적화를 수행하는 기법임. 이는 서브쿼리 Unnesting과 사실상 동일한 원리로 동작함.

#### 뷰 머징의 중요성

뷰는 복잡한 SQL을 단순화하고 재사용성을 높이는 데 목적이 있음. 그러나 성능 측면에서는 뷰가 **마치 없는 것처럼(투명하게)** 동작하여 옵티마이저가 최적의 실행 계획을 수립할 수 있도록 하는 것이 중요함. 뷰 머징이 바로 이 역할을 수행함.

#### 뷰 머징이 불가능한 경우 (Non-Mergeable View)

서브쿼리 Unnesting을 방해하는 요소(ROWNUM, 집계/분석 함수 등)가 뷰 정의에 포함되어 있으면 뷰 머징이 불가능함.

**Non-Mergeable View의 처리 방식**

1.  옵티마이저는 뷰를 독립적으로 실행하여 그 결과집합을 Temp 공간에 생성함.
2.  생성된 결과집합을 하나의 테이블처럼 간주하고 메인 쿼리의 테이블과 조인함.
3.  이 방식은 중간 결과집합을 생성하는 과정에서 추가적인 I/O와 메모리 사용을 유발하여 비효율적일 수 있음.

**튜닝 포인트**

  - 불필요하게 뷰 머징을 막는 요소가 있다면 제거하거나, 뷰를 사용하지 않고 직접 조인하는 방식으로 SQL을 재작성하는 것을 고려해야 함.
  - 반대로, `NO_MERGE` 힌트를 사용해 의도적으로 머징을 막아 특정 실행 계획을 유도하는 고급 튜닝 기법도 있음.

## 4.4.4 스칼라 서브쿼리 조인

### 스칼라 서브쿼리(Scalar Subquery) 정의

SELECT 절에 사용되며, 반드시 하나의 행, 하나의 컬럼만을 반환해야 하는 서브쿼리임. 주로 코드값을 명칭으로 변환하는 등의 용도로 사용됨.

### 스칼라 서브쿼리의 치명적인 문제점: 반복 수행

**동작 원리**
스칼라 서브쿼리는 기본적으로 메인 쿼리에서 조회된 **결과 건수만큼 반복 수행**되는 구조임. 예를 들어, 메인 쿼리가 10,000건을 조회하면, 스칼라 서브쿼리 역시 10,000번 호출되어 수행됨.

**성능 저하**

  - 매번 서브쿼리를 수행하면서 발생하는 I/O와 CPU 비용이 누적되어 심각한 성능 저하를 유발함.
  - 이를 보완하기 위해 **결과 캐싱(Result Cache)** 기능이 동작함. 즉, 동일한 입력값에 대해서는 서브쿼리를 재수행하지 않고 캐시에 저장된 결과값을 반환함.
  - 하지만 입력값이 모두 다르면 캐싱 효과가 없어 매번 수행해야 하는 근본적인 문제는 해결되지 않음.

### 스칼라 서브쿼리 튜닝: Outer Join으로의 변환

가장 확실하고 효과적인 튜닝 방법은 스칼라 서브쿼리를 \*\*아우터 조인(Outer Join)\*\*으로 변환하는 것임.

**변환 예시**

```sql
-- AS-IS: 비효율적인 스칼라 서브쿼리
-- (사원 테이블의 모든 건에 대해 부서명을 얻기 위한 서브쿼리가 반복 수행됨)
SELECT 사원번호,
       사원명,
       (SELECT 부서명 FROM 부서 WHERE 부서.부서코드 = 사원.부서코드) AS 부서명
  FROM 사원
 WHERE 입사일자 > '2024-01-01';

-- TO-BE: 효율적인 아우터 조인
-- (두 테이블을 먼저 조인한 후 결과집합을 조회하므로 반복 수행 문제가 없음)
SELECT A.사원번호,
       A.사원명,
       B.부서명
  FROM 사원 A
  LEFT OUTER JOIN 부서 B ON (A.부서코드 = B.부서코드)
 WHERE A.입사일자 > '2024-01-01';
```

**효과**

  - 반복 수행 구조를 제거하고, 옵티마이저가 NL Join, Hash Join 등 가장 효율적인 조인 방식을 선택할 수 있게 함.
  - 대부분의 경우 극적인 성능 향상을 기대할 수 있음.

-----

# 5장. 소트 튜닝

## 5.1 소트 연산에 대한 이해

### 5.1.1 소트 수행 과정

#### PGA와 Sort Area

  - **PGA (Program Global Area)**: 각 서버 프로세스에 할당되는 개별적인 메모리 영역이며 다른 프로세스와 공유되지 않음.
  - **Sort Area**: PGA 내에서 정렬 작업을 위해 사용되는 특정 메모리 공간임. `SORT_AREA_SIZE` 파라미터로 크기를 조절할 수 있음.

#### 소트의 두 가지 방식

**1. 메모리 소트 (Internal Sort / One-Pass Sort)**

  - **조건**: 정렬해야 할 전체 데이터가 Sort Area 내에 모두 수용될 수 있을 만큼 작은 경우에 발생함.
  - **과정**: 모든 정렬 작업이 메모리 내에서만 이루어짐.
  - **성능**: 디스크 I/O가 전혀 발생하지 않으므로 매우 빠름.

**2. 디스크 소트 (External Sort / Two-Pass Sort)**

  - **조건**: 정렬해야 할 데이터가 Sort Area보다 커서 메모리에 한 번에 올릴 수 없는 경우에 발생함.
  - **과정**:
    1.  **Sort Run 생성**: Sort Area에 담을 수 있는 만큼의 데이터를 가져와 메모리에서 정렬한 후, 이 중간 결과(Sort Run)를 디스크의 **Temp 테이블스페이스**에 임시로 기록함. 이 과정을 모든 데이터를 처리할 때까지 반복함.
    2.  **Merge**: 디스크에 기록된 여러 개의 Sort Run들을 다시 읽어와 병합하면서 최종 정렬된 결과집합을 만듦.
  - **성능**: 디스크 I/O가 필수적으로 발생하므로 성능이 매우 느림. **SQL 튜닝의 주요 대상**이 바로 이 디스크 소트를 최소화하거나 제거하는 것임.

### 5.1.2 소트 오퍼레이션

실행 계획에서 소트 발생 여부를 알려주는 대표적인 오퍼레이션들임.

  - **SORT (ORDER BY)**: `ORDER BY` 절 때문에 발생하는 가장 일반적인 소트임.
  - **SORT (GROUP BY)**: `GROUP BY` 연산을 위해 데이터를 그룹핑하기 전에 수행되는 소트이며, `HASH (GROUP BY)`로 대체될 수 있음.
  - **SORT (UNIQUE)**: `DISTINCT`나 `UNION` 연산 시 중복 레코드를 제거하기 위해 수행되는 소트임.
  - **SORT (AGGREGATE)**: `MIN`, `MAX` 같은 집계 함수를 처리할 때 발생함. 해당 컬럼에 인덱스가 있으면 인덱스 스캔으로 대체되어 소트가 발생하지 않을 수 있음.
  - **SORT (JOIN)**: `Sort Merge Join` 시 조인 키를 기준으로 양쪽 테이블을 각각 정렬할 때 발생함.

## 5.2 소트가 발생하지 않도록 SQL 작성

### 5.2.1 Union vs. Union All

#### 동작 원리의 차이

  - **UNION**: 두 개의 결과집합을 합친 후, 그 중에서 중복된 행을 **제거**함. 중복을 식별하려면 반드시 전체 데이터를 정렬하거나 해싱하는 과정이 필요하므로 **`SORT (UNIQUE)`** 오퍼레이션이 발생함.
  - **UNION ALL**: 두 개의 결과집합을 **그대로 이어 붙임**. 중복 제거 과정이 전혀 없으므로 소트나 해시 같은 부가적인 작업이 발생하지 않음.

#### 성능 비교

  - 데이터 처리량이 동일할 때, `UNION ALL`은 소트 비용이 없으므로 `UNION`에 비해 **항상 월등한 성능**을 보임.
  - 불필요하게 `UNION`을 사용하는 것은 시스템 자원을 낭비하고 성능을 저하시키는 대표적인 Bad SQL 습관임.

#### 튜닝 가이드

  - **"두 집합 간에 중복이 발생할 수 없다는 확신이 있거나, 중복이 허용되는 비즈니스 로직이라면, 반드시 `UNION ALL`을 사용해야 함."**

### 5.2.2 Exists 활용

#### Exists의 본질: '존재 확인 후 즉시 중단'

  - `EXISTS`는 서브쿼리의 조건을 만족하는 데이터가 **한 건이라도 존재하는지** 여부만 체크하는 연산자임.
  - 조건을 만족하는 첫 번째 행을 찾으면, 나머지 데이터를 더 이상 스캔하지 않고 **즉시 스캔을 멈추고** `TRUE`를 반환함.

#### IN 과의 비교

  - `IN`은 조건에 따라 서브쿼리의 결과집합 전체를 메모리에 올려두고 필터링하거나, 조인으로 변환되는 등 동작 방식이 다양하고 예측이 어려울 수 있음.
  - 특히 `NOT IN`은 `NULL` 값 처리 문제와 성능 이슈를 동시에 가질 수 있음.

#### 조인(Join)과의 비교

  - 일반 조인은 조인 조건에 맞는 모든 행의 조합을 생성하므로 결과 건수가 늘어날 수 있음.
  - 반면 `EXISTS`는 메인 쿼리의 행이 늘어나지 않으며, 단지 조건을 만족하는지 여부만 체크하는 **필터(Filter)** 역할만 함. 이러한 방식을 \*\*세미 조인(Semi-Join)\*\*이라고도 함.

#### 튜닝 가이드

  - **"다른 테이블에 특정 조건을 만족하는 데이터가 있는지 없는지만 확인하고 싶을 때"** `EXISTS`를 사용하면 가장 효율적임.
  - 서브쿼리의 컬럼 값을 실제 결과로 가져올 필요가 없고, 존재 여부 체크가 목적인 경우, 불필요한 조인이나 `IN` 서브쿼리 대신 `EXISTS`를 사용하면 I/O와 CPU 사용량을 크게 줄일 수 있음.
  - `EXISTS` 안에는 `SELECT *` 대신 `SELECT 'X'` 나 `SELECT 1` 을 사용하는 것이 일반적이나, 성능에 영향을 미치지는 않음. 코드의 의도를 명확히 하는 좋은 습관으로 볼 수 있음.