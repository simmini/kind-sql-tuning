# 3장 인덱스 튜닝

SQL 튜닝은 랜덤 I/O와의 전쟁이다. DBMS는 느린 랜덤 I/O를 극복하기 위해 많은 기능이 구현되어 있다.

## 테이블 랜덤 엑세스

> 인덱스로 검색하는데 왜 느릴까?

SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후 반드시 테이블을 액세스한다.

**인덱스 ROWID는 물리적 주소? 논리적 주소?**

ROWID는 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있다. 데이터파일 번호, 오브젝트 번호, 블록 번호와 같은 물리적인 요소로 구성되어 있지만, 물리적으로 직접 연결된 것은 아니다.

**메인 메모리 DB와의 비교**

메인 메모리 DB는 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 인덱스를 생성한다. 이때 인덱스는 메모리 상의 주소정보, 즉 포인트를 갖기 때문에 테이블을 액세스하는 비용이 낮다.

오라클은 계속 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조이다. 그래서 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 액세스가 생각보다 빠르지 않다.

**버퍼 캐시**

I/O 성능을 높이려면 버퍼 캐시를 활용해야 한다. 데이터를 찾기 위해서는 블록 주소가 필요한데, 버퍼 캐시에서 먼저 찾아보고, 못 찾으면 디스크에서 블록을 읽고 버퍼 캐시에 적재한다.

여기서 모든 데이터가 캐싱되어 있어도, 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래피 획득 과정을 반복해야 하므로 ROWID를 이용한 테이블 액세스는 생각보다 고비용이다.

**인덱스 ROWID는 생각보다 느리다.**

ROWID는 우편주소, 메인 메모리 DB가 사용하는 포인터는 전화번호에 비유할 수 있다. 전화는 물리적으로 연결되어 있어 전화번호만 누르면 상대와 통화할 수 있지만, 우편은 우체부 아저씨가 찾아다니는 구조이므로 느리다.

## 인덱스 클러스터링 팩터

특정 컬럼 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. CF가 좋으면 검색 효율이 매우 좋다. 데이터가 물리적으로 모여있기 때문에 흩어져 있을 때보다 블록 I/O가 적게 발생하기 때문이다.

## 인덱스 손익 분기점

읽어야 할 데이터가 일정량을 넘어서면 인덱스를 이용한 테이블 액세스는 테이블 풀스캔보다 느려진다. Index Range Scan에 의한 테이블 액세스가 Table Fuul Scan보다 느려지는 지점을 인덱스 손익분기점이라고 한다.

Index Range Scan이 더 느려지게 하는 핵심 이유는 다음과 같다.

- Table Full Scan은 시퀀셜 액세스, Index Range Scan은 랜덤 액세스
- Table Full Scan 은 Multiblock I/O, Index Range Scan은 Single Block I/O
