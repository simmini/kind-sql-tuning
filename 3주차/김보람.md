## 친절한 SQL 튜닝 3장: 인덱스 튜닝 정리



### **1. 인덱스와 테이블 액세스 최소화**

- **인덱스 ROWID**  
  인덱스의 ROWID는 *논리적 주소*로, 테이블 레코드를 찾아가기 위한 정보입니다. 인덱스를 스캔한 뒤 실제 데이터는 테이블에서 읽어야 하므로, 인덱스만으로 처리가 끝나지 않는 한 테이블 액세스가 발생합니다

- **랜덤 I/O 최소화**  
  SQL 튜닝의 핵심은 랜덤 I/O를 줄이는 것입니다. 인덱스를 잘 활용하면 테이블 전체를 읽는 Full Scan 대신 필요한 데이터만 빠르게 찾을 수 있습니다

---

### **2. 인덱스 컬럼 추가와 설계**

- **인덱스 컬럼 추가**  
  가장 널리 쓰이는 튜닝 방법은 기존 인덱스에 컬럼을 추가하는 것입니다. 예를 들어, 기존 인덱스가 `deptno+job`일 때, `sal` 컬럼을 추가하면 테이블 랜덤 액세스 횟수를 크게 줄일 수 있습니다.
  인덱스 스캔량은 그대로지만, 테이블을 읽는 횟수가 줄어 전체 성능이 개선됩니다

- **Covered 인덱스**  
  인덱스에 쿼리에서 필요한 모든 컬럼이 포함되어 있으면, 테이블을 액세스하지 않고 인덱스만으로 결과를 반환할 수 있습니다. 이를 *Covered 쿼리* 또는 *Include 인덱스*라고 합니다

- **인덱스 설계 시 주의점**  
  인덱스를 무분별하게 추가하면 DML(Insert/Update/Delete) 부하가 커지고, 관리 비용이 증가하므로 꼭 필요한 컬럼만 신중하게 추가해야 합니다

---

### **3. 인덱스 스캔 효율화**

- **액세스 조건 vs 필터 조건**  
  - *액세스 조건*: 인덱스 스캔 범위를 결정하는 조건절(WHERE 절에서 인덱스가 실제로 사용되는 부분)
  - *필터 조건*: 인덱스 스캔 후, 테이블에서 추가로 필터링하는 조건절  
  인덱스 선행 컬럼이 WHERE 조건에 있어야 인덱스가 효율적으로 사용됩니다

- **IN, BETWEEN, LIKE 조건의 활용**  
  - `BETWEEN`보다 `IN-List`가 인덱스 활용에 더 효과적일 때가 많으며, 대량의 IN-List는 NL 조인이나 서브쿼리로 대체하는 것이 좋습니다
  - 숫자형 컬럼에 LIKE를 쓰면 인덱스 효율이 떨어지므로, 가급적 사용을 피해야 합니다

- **클러스터링 팩터(군집성 계수)**  
  인덱스의 클러스터링 팩터는 특정 컬럼 값이 물리적으로 얼마나 잘 모여 있는지 나타냅니다. 값이 모여 있을수록 인덱스 효율이 높아집니다

---

### **4. 실전 팁 및 주의사항**

- **온라인 vs 배치 프로그램**  
  - 온라인 프로그램: 소량 데이터 처리, 인덱스 적극 활용, NL 조인 선호
  - 배치 프로그램: 대량 데이터 처리, 전체 범위 처리 기준으로 튜닝

- **사용자 정의 함수 활용**  
  WHERE 조건에 사용자 정의 함수를 직접 쓰지 말고, 먼저 범위를 좁힌 뒤 함수 조건을 적용하는 것이 효율적입니다

---

### **5. 예시 쿼리**

```sql
-- 인덱스 컬럼 추가 전
SELECT * FROM emp WHERE deptno = 30 AND sal >= 2000;

-- 인덱스 컬럼 추가 후 (deptno+job+sal)
-- 각 job에서 sal 2000 이상인 레코드를 빠르게 찾을 수 있음

-- IN-List 활용 예시
SELECT * FROM 매물아파트매매
WHERE 인터넷매물 IN ('1', '2', '3')
  AND 아파트시세코드 = 'A0101';
```

