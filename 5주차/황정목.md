# 인덱스 스캔 효율화 — 왜 인덱스를 타도 느릴까?

## 3.3. 인덱스를 더 잘 쓰기 위한 12가지 진실

### 3.3.1 인덱스 탐색 (Index Access Path)

옵티마이저는 인덱스를 활용할지 말지를 결정할 때, 선행 조건 컬럼을 얼마나 효율적으로 찾을 수 있느냐를 본다.
B-Tree 인덱스는 정렬된 구조이기에 범위 탐색에 적합하며, 이 구조를 어떻게 활용할 것인지가 관건이다.

### 3.3.2 인덱스 스캔 효율성

인덱스를 쓴다고 무조건 좋은 게 아니다.
- 인덱스 스캔 + 테이블 액세스가 많으면 오히려 비효율
- 특히 랜덤 액세스가 많은 경우 주의

인덱스 커버링 여부와 클러스터링 팩터를 항상 확인하라

### 3.3.3 액세스 조건 vs 필터 조건
- 액세스 조건: 인덱스를 타고 자료를 좁히는 데 직접 사용되는 조건
- 필터 조건: 인덱스는 타지만, 레코드 조회 후 필터링

```sql
-- user_id = 1: 액세스 조건
-- age > 30: 필터 조건
SELECT * FROM users WHERE user_id = 1 AND age > 30;
```

인덱스 설계 시 액세스 조건 컬럼부터 앞에 배치해야 한다.

### 3.3.4 비교 연산자와 컬럼 순서에 따른 군집성

다중 컬럼 인덱스에서:

```sql
CREATE INDEX idx_user ON users(dept_id, gender);
```

- dept_id = 10 AND gender = 'F': 군집도 좋음
- gender = 'F'만 조건으로 쓰면? → 인덱스 무시되거나 Skip Scan

인덱스 선행 컬럼은 항상 '=' 조건일수록 효과적

3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

```sql
-- 비효율 예시
SELECT * FROM users WHERE dept_id > 100 AND gender = 'M';
```

선행 컬럼 dept_id가 범위 조건이므로, 후행 컬럼 gender는 인덱스 탐색에 기여하지 못함

가능하면 '=' 조건으로 앞 컬럼을 고정할 수 있는 방식으로 쿼리 구성하자

3.3.6 BETWEEN을 IN-List로 전환

BETWEEN은 범위 조회지만, IN으로 명시하면 더 많은 옵티마이저 최적화 기회를 제공한다.

```sql
-- 비교
WHERE user_id BETWEEN 1 AND 3
-- 변환
WHERE user_id IN (1, 2, 3)
```

IN 리스트는 병렬 인덱스 스캔이 가능하여 성능 향상 가능

3.3.7 Index Skip Scan 활용

선행 컬럼이 고정되지 않아도 후행 컬럼으로 인덱스를 사용할 수 있는 고급 기법.

```sql
CREATE INDEX idx_user ON users(dept_id, gender);
```

```sql
-- dept_id 없이 gender만 조건인 경우
WHERE gender = 'M'
```

Skip Scan이 가능하지만, 효율은 선행 컬럼의 유니크도에 따라 다름

선행 컬럼의 카디널리티가 낮을수록 Skip Scan이 유리

3.3.8 IN 조건은 '='인가?

IN 조건은 내부적으로 다수의 '=' 조건으로 분해되어 평가됨

```sql
WHERE dept_id IN (10, 20, 30)
```

옵티마이저는 dept_id = 10 OR dept_id = 20 OR dept_id = 30으로 판단

IN 조건을 사용하면 인덱스 범위 분할이 가능하므로 유리

### 3.3.9 BETWEEN과 LIKE의 스캔 범위 비교
- BETWEEN은 시작값과 끝값이 명확하므로 효율적
- LIKE 'ABC%'도 내부적으로는 BETWEEN과 비슷한 인덱스 범위 스캔 수행

```sql
LIKE 'ABC%' → WHERE name BETWEEN 'ABC' AND 'ABCzzzz'
```

하지만

```sql
LIKE '%ABC%' → 인덱스 못 탐  
```

접두어 조건이 아니라면 인덱스 의미 없음 → Full Scan 발생

3.3.10 범위검색 조건 남용에 따른 비효율

```sql
WHERE salary > 3000
```

조건은 간단해 보여도 인덱스 범위가 너무 넓다면 성능 폭탄

옵티마이저는 풀스캔으로 우회할 수 있음 

히스토그램 통계 활용 여부 확인

3.3.11 다양한 옵션 조건 처리 방식 비교

옵션이 많은 경우는 일반적으로 OR 조건, 또는 UNION ALL로 처리할 수 있음.

```sql
-- 1안: OR
WHERE type = 'A' OR type = 'B'

-- 2안: UNION
SELECT ... WHERE type = 'A'
UNION ALL
SELECT ... WHERE type = 'B'
```

UNION ALL이 인덱스 활용, 병렬 처리, 캐시 효율성 측면에서 더 유리한 경우가 많음

3.3.12 함수 호출 부하 해소를 위한 인덱스 구성

```sql
-- 비효율
WHERE TO_CHAR(reg_date, 'YYYY-MM-DD') = '2025-06-03'
```

인덱스가 있어도 함수로 인해 무효화됨

해결책:
- 함수 결과를 컬럼으로 분리하여 저장 (예: reg_date_str)
- 또는 Function-Based Index 생성

```sql
CREATE INDEX idx_date_fmt ON users(TO_CHAR(reg_date, 'YYYY-MM-DD'));
```

## 3.4. 공식보다 중요한 전략적 사고

### 3.4.1 인덱스 설계가 어려운 이유

왜 인덱스를 설계하는 것이 어려울까요? 바로 정답이 없기 때문.

- 테이블 크기, 트래픽 패턴, SELECT vs INSERT/UPDATE 비율 등 다변수 문제
- 개발 시점에는 사용 패턴이 불확실
- 성능 개선은 사후적으로만 검증 가능

따라서, 정형화된 룰보다 전략적 사고 + 로그 기반 튜닝이 핵심이다.

### 3.4.2 가장 중요한 두 가지 선택 기준

인덱스 설계의 핵심은 "무엇을 인덱싱할 것인가"와 "어떤 순서로 구성할 것인가"에 대한 명확한 기준을 갖는 것이다. 실무적으로 가장 중요한 두 가지 판단 기준은 다음과 같다.

1. 조건절에 항상 또는 자주 사용되는 컬럼을 먼저 선정할 것
- WHERE, JOIN ON, HAVING, ORDER BY 등에 반복적으로 등장하는 컬럼
- 사용자의 조회 패턴에서 빠지지 않는 핵심 컬럼

인덱스를 만들기 전, 쿼리 로그나 APM(예: New Relic, Datadog)으로 컬럼 사용 패턴을 파악하세요.

2. '=' 조건으로 자주 조회되는 컬럼을 인덱스의 앞쪽에 배치할 것
- 결합 인덱스((A, B, C) 등)에서 선행 컬럼이 = 조건일 때 후행 컬럼까지도 인덱스가 효과적으로 사용됨
- 반대로, 앞 컬럼이 >나 LIKE 같은 범위 조건이면 후행 컬럼은 무시됨

선행 컬럼이 '=' 조건일수록 옵티마이저가 Index Range Scan이나 Index Unique Scan을 유도할 수 있음

### 3.4.3. 스캔 효율성 이외의 판단 기준

인덱스 설계는 단순히 "스캔이 빠를 것 같으니 만들자"는 식의 단순 판단만으로는 부족하다. 반드시 고려해야 할 현실적인 기준이 있다.

- DML 부하
인덱스가 많을수록 INSERT, UPDATE, DELETE 성능은 급격히 저하된다.
특히 다중 인덱스를 가진 테이블에서 대량의 쓰기가 일어나면 인덱스 리프 노드 분할, 정렬 등의 부하가 심각해진다.
- 저장 공간
인덱스는 디스크와 캐시 모두 차지한다. 특히 커버링 인덱스는 여러 컬럼을 포함하므로 크기 부담이 크다.
- 유지 관리 비용
스키마 변경, 쿼리 패턴 변경이 생길 경우 기존 인덱스가 무용지물이 될 수 있다. 정기적인 검토가 필요하다.

인덱스는 **"있는 게 이득"이 아니라, "잘 쓰일 때만 이득"**이라는 점을 기억하세요.

### 3.4.4 공식을 초월한 전략적 설계

많은 개발자가 "선택도 높은 컬럼을 앞에 두라", "범위 조건은 뒤에 둬라" 같은 공식을 따른다.
하지만 실제 현장에서는 트래픽 유형, 데이터 분포, 비즈니스 요구에 따라 유연한 판단이 필요하다.

예시 전략:
- 읽기 중심 시스템
→ 자주 사용하는 SELECT 쿼리를 커버하는 인덱스를 설계
- 쓰기 중심 시스템 (예: IoT, 실시간 수집 테이블)
→ 인덱스를 최소화하거나 파티셔닝 중심으로 설계
- 쿼리 리포트 중심 시스템
→ 정렬 및 집계 조건을 고려한 정렬형 인덱스 사용

공식은 참고일 뿐, 설계는 전략이다.

### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

정렬이 필요한 쿼리를 인덱스로 해결하면, DB는 정렬을 생략하고 인덱스 순서대로 결과를 반환할 수 있다.

BEFORE: 정렬 필요

```sql
SELECT * FROM posts WHERE category = 'news' ORDER BY created_at DESC;
```

AFTER: 정렬 불필요 (커버링 인덱스)

```sql
CREATE INDEX idx_posts_cat_created ON posts(category, created_at DESC);
```

ORDER BY, GROUP BY에서 반복되는 컬럼은 반드시 인덱스 컬럼으로 고려해보자

### 3.4.6 결합 인덱스 선택도

결합 인덱스에서 성능을 좌우하는 요소는 선행 컬럼이 얼마나 많은 결과를 거를 수 있느냐이다.
- 선택도 높은 컬럼을 앞에, 낮은 컬럼을 뒤에
- 자주 함께 사용되는 컬럼은 인접하게 배치

예:

```sql
CREATE INDEX idx_emp ON employee(department_id, gender);
```

- department_id = 10 AND gender = 'M'
→ 효과적
- gender = 'M'만 쿼리
→ 선행 컬럼 미지정 → 인덱스 무효 → Skip Scan 시도 (효율 떨어짐)

선택도 높은 컬럼이 필터 역할을 하기 때문에, 반드시 앞에 둬야 효과적입니다.


### 3.4.7 중복 인덱스 제거

다음과 같은 인덱스가 있다고 가정해봅시다:
- idx_user_id: (user_id)
- idx_user_id_status: (user_id, status)

이 경우, 후자가 전자의 기능을 포함하고 있기 때문에 idx_user_id는 중복 인덱스.

중복 인덱스 제거 체크리스트:
- 인덱스 포함 관계 확인
- 사용 빈도가 낮은 인덱스 우선 제거
- 조회 대상 컬럼의 차이가 없으면 통합

중복 인덱스는 성능을 떨어뜨릴 뿐만 아니라, 공간 낭비와 DML 부하를 초래한다.

### 3.4.8 인덱스 설계도 작성

인덱스를 체계적으로 관리하려면 설계도 문서화가 반드시 필요하다.
이는 DB 성능 운영과 유지보수의 핵심 자산.

인덱스 설계도에 포함할 항목:

테이블명 : ex) orders
주요 쿼리 패턴 : ex) customer_id + order_date 조회
인덱스명 및 컬럼 : ex) idx_orders_cust_date (customer_id, order_date)
쿼리 적중 여부 : 커버링 여부, 정렬 생략 여부
생성 이유 및 목적 : 성능 개선 대상 쿼리 번호와 설명
예상 부작용 : DML 부하 여부, 중복 여부 등

설계도는 향후 스키마 리팩터링과 성능 이슈 분석 시에도 큰 도움이 된다.
