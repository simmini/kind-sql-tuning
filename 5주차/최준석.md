# 3장. 인덱스 튜닝 - 상세 정리

## 핵심 개념 정리

**SQL 튜닝의 본질: 랜덤 I/O와의 전쟁**

SQL 튜닝은 결국 랜덤 I/O를 어떻게 처리하느냐에 달려 있습니다. 대부분의 DBMS 기능과 튜닝 기법들이 느린 랜덤 I/O를 극복하기 위해 개발되었습니다.

**인덱스 튜닝의 2가지 핵심 요소**

1. **인덱스 스캔 효율화**: 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
2. **랜덤 액세스 최소화**: 인덱스 스캔 후 테이블에 접근하는 횟수를 줄이는 것

---

## 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

#### 기본 개념

SQL에서 참조하는 컬럼을 인덱스가 모두 포함하지 않으면, 인덱스 스캔 후 반드시 테이블을 액세스해야 합니다. 실행계획에서 "TABLE ACCESS (BY INDEX ROWID)" 부분이 이에 해당합니다.

**인덱스 사용 목적**

- 조건에 맞는 소량의 데이터를 빨리 찾기
- 얻은 ROWID를 이용해서 테이블 레코드를 찾아가기
- ROWID는 테이블 레코드를 찾아가기 위한 주소값

#### 디스크 DB에서 ROWID를 이용한 테이블 액세스가 느린 이유

**메모리 관리 방식의 차이**

- 오라클과 같은 디스크 DB는 메모리(버퍼캐시)에 테이블 블록을 올려놓음
- 버퍼캐시의 테이블 블록은 수시로 변경되고 다른 공간에 캐싱됨
- 인덱스에서는 메모리 주소가 아닌 디스크 주소 정보를 이용
- 해시 알고리즘을 통해 버퍼 블록을 찾아야 함

**메인 메모리 DB와의 성능 차이**

- 메인 메모리 DB는 메모리상의 주소정보(Pointer)를 직접 사용하여 매우 빠름
- 디스크 DB는 잘 튜닝되어 버퍼 캐시 히트율이 99% 이상이어도 성능 차이 발생
- 대량 인덱스 액세스 시 엄청난 차이를 보임

#### 인덱스를 이용하여 테이블 블록을 찾아가는 과정

**상세 단계**

1. **인덱스 스캔**: 리프 블록에서 읽은 ROWID를 분해해서 DBA(Database Block Address) 정보 획득
2. **해시 체인 찾기**: DBA를 해시 함수에 입력해서 해시 체인을 찾음
3. **버퍼 헤더 찾기**: 해시 체인을 통해 버퍼 헤더를 찾음 (버퍼 헤더는 항상 같은 해시 체인에 연결)
4. **버퍼 블록 접근**: 버퍼 헤더를 통해 버퍼 블록을 찾음 (버퍼 블록은 캐싱될 때마다 위치 변경)

**비용 발생 요인**

- 모든 데이터가 캐시되어 있어도 매번 DBA 해싱과 래치 획득 과정 반복
- 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 비용이 많이 드는 작업

### 3.1.2 인덱스 클러스터링 팩터

#### 클러스터링 팩터(Clustering Factor, CF) 정의

특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여 있는 정도를 의미합니다.

**CF가 좋은 경우**

- 고객 데이터가 물리적으로 근접해 있음
- 흩어져 있을 때보다 데이터 찾는 속도가 빠름
- 테이블 액세스량에 비해 블록 I/O가 적게 발생
- 검색 효율이 좋음

**CF가 나쁜 경우**

- 같은 테이블을 반복 액세스하면서 논리적 I/O와 물리적 I/O 증가
- 인덱스 손익분기점이 5% 미만까지 낮아질 수 있음

#### 버퍼 Pinning

**개념**

- 인덱스 ROWID로 테이블 액세스 시, 찾아간 테이블 블록에 대한 포인터를 바로 해제하지 않고 유지
- 다음 인덱스 레코드가 직전과 같은 테이블 블록을 가리키면 래치 획득과 체인 스캔 과정 생략 가능
- 논리적인 블록 I/O 과정을 생략할 수 있음

### 3.1.3 인덱스 손익분기점

#### 정의

Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점

#### Table Full Scan의 특성

- **성능 일정**: 1000만건 중 1건 조회하거나 10만건 조회해도 차이 거의 없음
- **예측 가능**: 전체 테이블 크기에 비례하는 일정한 성능

#### 인덱스를 이용한 테이블 액세스의 특성

- **가변 성능**: 전체 데이터 중 몇 건을 조회하는지에 따라 성능이 크게 달라짐
- **소량 데이터**: 매우 효율적
- **대량 데이터**: Table Full Scan보다 느려짐

#### 인덱스 손익분기점이 낮은 핵심 요인

**1. 액세스 방식의 차이**

- **Table Full Scan**: 시퀀셜 액세스
- **인덱스 ROWID**: 랜덤 액세스

**2. I/O 방식의 차이**

- **Table Full Scan**: Multiblock I/O
- **인덱스 ROWID**: Single Block I/O

**결론**

- 일반적으로 5~20% 수준에서 손익분기점 결정
- CF(클러스터링 팩터)에 따라 달라질 수 있음
- CF가 나쁜 경우 5% 미만에서도 손익분기점 형성 가능

### 3.1.4 인덱스 컬럼 추가

#### 기본 개념

테이블 액세스를 최소화하기 위해 가장 일반적으로 사용하는 튜닝 기법

#### 실제 예시

```sql
-- 기존 인덱스: emp_x01 (deptno + job)
SELECT * FROM emp WHERE deptno = 30 AND sal >= 2000;
```

**문제 상황**

- deptno=30이며 sal>=2000 조건을 만족하는 레코드가 단 1개
- 하지만 인덱스에서 deptno=30인 사원 모두를 스캔해야 함
- 각 사원마다 테이블 액세스 발생

**해결 방법**

- 기존 인덱스에 sal 컬럼 추가
- 인덱스 구성을 쉽게 변경하기 어려운 운영 환경에서 유용
- 인덱스 스캔량은 동일하지만 테이블 랜덤 액세스 횟수 감소

**효과**

- 테이블 랜덤 액세스 횟수 대폭 감소
- 전체적인 쿼리 성능 향상
- 기존 인덱스 활용으로 추가 저장공간 최소화

### 3.1.5 인덱스만 읽고 처리 (Covered 쿼리)

#### Covered 쿼리란?

쿼리에서 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스를 아예 발생하지 않게 하는 방법

**장점**

- 테이블 랜덤 액세스 완전 제거
- 쿼리 성능 극대화
- I/O 비용 최소화

**단점**

- 인덱스에 추가해야 할 컬럼이 많아서 실제 적용 곤란한 경우가 많음
- 인덱스 크기 증가로 인한 저장공간 부담
- DML 성능에 미치는 영향 증가

#### Include 인덱스

**개념**

- 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
- 테이블 랜덤 액세스를 줄이는 용도로 개발

**일반 인덱스와의 차이**

- **일반 인덱스**: 모든 컬럼이 루트와 브랜치 블록에 저장 → 수직적 탐색에서 사용 가능
- **Include 인덱스**: Include 컬럼은 리프 블록에만 저장 → 수평적 탐색 시에만 사용 가능

**활용 예시**

```sql
-- emp_x02: deptno, sal (일반 인덱스)
-- emp_x01: deptno + Include(sal) (Include 인덱스)

SELECT * FROM emp WHERE deptno = 30 ORDER BY sal;
```

- emp_x02: 소트 연산 생략 가능 (sal이 루트/브랜치에도 저장)
- emp_x01: 소트 연산 생략 불가 (sal이 리프에만 저장)

### 3.1.6 인덱스 구조 테이블 (IOT)

#### 개념

인덱스를 이용한 테이블 액세스가 고비용 구조이므로 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성

**DBMS별 명칭**

- **Oracle, Tibero**: IOT(Index Organized Table)
- **MS SQL Server**: 클러스터형(Clustered) 인덱스

#### IOT의 특징

**구조적 특징**

- 테이블 데이터를 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 IOT는 그 자리에 테이블 데이터를 포함
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장
- ROWID 대신 실제 테이블 데이터 저장

**데이터 입력 방식**

- 일반 힙 구조 테이블: 랜덤 방식으로 데이터 입력
- IOT: 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터 입력

**성능 특성**

- **장점**: 테이블 랜덤 액세스 완전 제거, 빠른 검색 성능
- **단점**: 정렬 작업 발생으로 데이터 변경 시 성능 저하 가능
- **적용 제한**: 잦은 데이터 입력, 수정, 삭제가 있는 경우 부적합

### 3.1.7 클러스터 테이블

#### 인덱스 클러스터

**개념**

- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조
- 한 블록에 담을 수 없을 때는 다른 블록에 할당하고 클러스터 체인으로 연결

**다중 테이블 클러스터**

- 여러 테이블 레코드를 같은 블록에 저장 가능
- 일반 테이블은 하나의 데이터 블록을 여러 테이블이 공유할 수 없음
- 관련된 테이블들을 물리적으로 근접하게 저장하여 조인 성능 향상

**장점**

- 관련 데이터의 물리적 근접성으로 I/O 감소
- 조인 성능 향상
- 클러스터링 팩터 개선

#### 해시 클러스터 테이블

**개념**

- 인덱스를 사용하지 않고 해시 알고리즘을 사용해서 클러스터를 찾아감
- 인덱스 클러스터와의 주요 차이점

**특징**

- 해시 함수를 통해 직접 데이터 블록 접근
- 인덱스 탐색 과정 생략
- 등치 조건 검색에 최적화
- 범위 검색에는 부적합

**적용 기준**

- 주로 등치 조건으로 액세스하는 테이블
- 테이블 크기가 상대적으로 작고 안정적인 경우
- 해시 충돌 최소화를 위한 적절한 해시 버킷 크기 설정 필요

---

## 3.2 부분범위 처리 활용

### 3.2.1 부분범위 처리

#### 개념

전체 결과집합을 일부분씩 나누어 전송하는 기법

**전체범위 처리 vs 부분범위 처리**

- **전체범위 처리**: 쿼리 결과를 모두 읽어서 클라이언트에게 전송
- **부분범위 처리**: 결과집합의 일부분만 먼저 전송하고 사용자 요청 시 추가 전송

#### 부분범위 처리의 장점

**응답성 향상**

- 사용자가 첫 번째 결과를 빠르게 볼 수 있음
- 대량 데이터 조회 시에도 즉시 응답 가능

**자원 절약**

- 불필요한 네트워크 트래픽 감소
- 메모리 사용량 감소
- CPU 자원 절약

**사용자 경험 개선**

- 페이징 처리로 인한 사용자 편의성 향상
- 필요한 데이터만 조회하는 패턴 유도

### 3.2.2 부분범위 처리 구현

#### Array Size 조정

```sql
-- 클라이언트에서 한 번에 가져올 레코드 수 조정
SET ARRAYSIZE 100
```

#### ROWNUM을 이용한 구현

```sql
-- 상위 N개 조회
SELECT * FROM (
    SELECT * FROM 테이블 ORDER BY 정렬컬럼
) WHERE ROWNUM <= 10;

-- 페이징 처리
SELECT * FROM (
    SELECT ROWNUM rn, a.* FROM (
        SELECT * FROM 테이블 ORDER BY 정렬컬럼
    ) a WHERE ROWNUM <= 20
) WHERE rn > 10;
```

#### 커서 활용

```sql
DECLARE
    CURSOR c1 IS SELECT * FROM 테이블 ORDER BY 정렬컬럼;
BEGIN
    FOR rec IN c1 LOOP
        -- 레코드 처리
        EXIT WHEN c1%ROWCOUNT > 100; -- 100건까지만 처리
    END LOOP;
END;
```

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

#### OLTP 시스템의 특성

- **소량 데이터 조회**: 주로 소량의 데이터를 빠르게 조회
- **빈번한 트랜잭션**: 많은 사용자가 동시에 짧은 트랜잭션 수행
- **응답성 중시**: 사용자 응답성이 가장 중요한 요소

#### 성능개선 원리

**인덱스와의 시너지**

- 인덱스를 통한 정렬된 데이터 접근
- 부분범위 처리로 필요한 만큼만 스캔
- 전체 데이터를 읽지 않고 조기 종료 가능

**실행계획 최적화**

```sql
-- 비효율적: 전체 데이터 정렬 후 상위 10건 선택
SELECT * FROM (
    SELECT * FROM 대용량테이블 ORDER BY 날짜 DESC
) WHERE ROWNUM <= 10;

-- 효율적: 인덱스를 통한 정렬 상태 활용
SELECT * FROM 대용량테이블
WHERE 인덱스컬럼 IS NOT NULL
ORDER BY 인덱스컬럼 DESC
FETCH FIRST 10 ROWS ONLY;
```

**메모리 사용 최적화**

- Sort Area 사용량 감소
- Buffer Cache 효율성 증대
- PGA 메모리 절약

---

## 3.3 인덱스 스캔 효율화

### 3.3.1 인덱스 탐색

#### 수직적 탐색 (Vertical Scan)

**목적**: 조건을 만족하는 **첫 번째** 레코드를 찾는 과정

**중요 포인트**

- '조건을 만족하는 레코드'를 찾는 것이 아님
- '조건을 만족하는 **첫 번째** 레코드'를 찾는 것
- 인덱스 스캔 시작지점을 결정

**과정**

1. 루트 블록에서 시작
2. 찾으려는 값과 같거나 큰 첫 번째 값 탐색
3. 해당 값의 직전 레코드가 가리키는 하위 블록으로 이동
4. 리프 블록에 도달할 때까지 반복

#### 수평적 탐색 (Horizontal Scan)

**목적**: 찾고자 하는 데이터가 더 나타나지 않을 때까지 인덱스 리프 블록을 수평적으로 스캔

**특징**

- 인덱스에서 본격적으로 데이터를 찾는 과정
- 리프 블록끼리는 양방향 연결 리스트 구조
- 조건을 만족하지 않는 레코드를 만날 때까지 계속 스캔

### 3.3.2 인덱스 스캔 효율성

#### 효율성 측정 방법

SQL 트레이스를 통해 인덱스 스캔 효율성을 확인할 수 있습니다.

**주요 지표**

- **인덱스 블록 읽기 횟수**: 스캔한 인덱스 블록 수
- **테이블 블록 읽기 횟수**: 액세스한 테이블 블록 수
- **처리된 레코드 수**: 실제로 결과로 반환된 레코드 수

**효율성 계산**

```
인덱스 스캔 효율성 = 결과 레코드 수 / 인덱스에서 스캔한 레코드 수 × 100%
```

### 3.3.3 액세스 조건과 필터 조건

#### 1. 인덱스 액세스 조건 (Access Condition)

**정의**: 인덱스 스캔 범위를 결정하는 조건절

**역할**

- 인덱스 수직적 탐색을 통해 스캔 시작점 결정
- 인덱스 리프 블록을 스캔하다가 어디서 멈출지 결정
- 스캔 범위를 최소화하는 핵심 요소

#### 2. 인덱스 필터 조건 (Filter Condition)

**정의**: 테이블로 액세스할지를 결정하는 조건절

**특징**

- 인덱스에서 조건을 확인하지만 스캔 범위는 줄이지 못함
- 랜덤 액세스를 줄이는 역할
- 18c부터 인덱스 구성 컬럼 중 하나 이상이 Not Null이면 필터 조건으로 사용 가능

#### 3. 테이블 필터 조건

**정의**: 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정

**역할**

- 테이블에서 레코드를 읽은 후 조건 확인
- 최종 결과집합 구성

#### 비용 계산 공식

```
총 비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용

상세 분해:
= 인덱스 루트와 브랜치 레벨에서 읽는 블록 수
+ 인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수
+ 테이블 액세스 과정에 읽는 블록 수
```

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

#### 선행 컬럼의 중요성

**핵심 원칙**

- 선행 컬럼이 '=' 조건일 때 데이터가 군집되어 있음
- 중간 컬럼이 범위 검색인 경우 그 뒤 레코드들이 흩어짐
- **첫 번째 나타나는 범위검색 조건**이 인덱스 스캔 범위를 결정

#### 예시로 이해하기

```sql
-- 인덱스: (지역, 직업, 연령)
WHERE 지역 = '서울'        -- 액세스 조건 (=)
  AND 직업 BETWEEN 'A' AND 'Z'  -- 액세스 조건 (범위검색)
  AND 연령 = 30            -- 필터 조건
```

**분석**

- 지역='서울' 조건으로 데이터가 군집됨
- 직업 BETWEEN 조건이 첫 번째 범위검색이므로 스캔 범위 결정
- 연령=30 조건은 필터 조건으로 작동 (스캔 범위 줄이는 효과 제한적)

#### 범위검색 이후 '=' 조건의 효과

범위검색 이후의 '=' 조건도 인덱스 액세스 조건에 적용되지만, 맨 처음과 마지막 구간에서의 스캔량을 줄여주는 정도의 효과만 있습니다.

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

#### 문제 상황

인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위 검색 조건일 때 비효율 발생

#### 구체적 예시

```sql
-- 인덱스: (상품분류, 등록일자, 상품명)

-- 비효율적인 경우
WHERE 등록일자 BETWEEN '20220101' AND '20220131'
  AND 상품명 = '특정상품'

-- 효율적인 경우
WHERE 상품분류 = 'A'
  AND 등록일자 BETWEEN '20220101' AND '20220131'
  AND 상품명 = '특정상품'
```

**비효율 원인**

- 선행 컬럼(상품분류) 조건이 없어서 인덱스 전체 스캔
- 등록일자 조건만으로는 스캔 범위가 넓어짐
- 상품명 조건은 필터 조건으로만 작동

### 3.3.6 BETWEEN을 IN-List로 전환

#### 기본 개념

BETWEEN 조건을 IN-List로 변환하여 각각의 수직적 탐색을 통해 효율성 증대

#### 변환 예시

```sql
-- 비효율적: BETWEEN 사용
WHERE 상품코드 BETWEEN 'A001' AND 'A999'

-- 효율적: IN-List 사용 (데이터 분포에 따라)
WHERE 상품코드 IN ('A001', 'A002', 'A003', ..., 'A999')

-- UNION ALL 방식
SELECT * FROM 테이블 WHERE 상품코드 = 'A001'
UNION ALL
SELECT * FROM 테이블 WHERE 상품코드 = 'A002'
UNION ALL
...
```

#### 고려사항

**장점**

- 각 값마다 수직적 탐색으로 정확한 시작점 찾기
- 스캔 범위 최소화
- 데이터가 듬성듬성 분포된 경우 효과적

**단점**

- IN-List 항목 개수가 많아지면 비효율적
- 수직적 탐색 비용이 증가할 수 있음
- SQL 복잡도 증가

**적용 기준**

- IN-List 개수가 많지 않을 때만 유용
- 데이터 분포와 수직적 탐색 비용을 고려해야 함
- 일반적으로 10~20개 이하일 때 효과적

#### 대안 방법

```sql
-- IN-List 항목이 많을 때: NL 조인 방식
SELECT /*+ USE_NL(a b) */ *
FROM 테이블 a, 조건테이블 b
WHERE a.상품코드 = b.상품코드;

-- 서브쿼리 방식
SELECT * FROM 테이블
WHERE 상품코드 IN (SELECT 상품코드 FROM 조건테이블);
```

### 3.3.7 Index Skip Scan 활용

#### 개념

선두 컬럼이 조건절에 없거나 변별력이 나쁠 때, 선두 컬럼의 Distinct Value 개수만큼 Index Range Scan을 반복 수행하는 기법

#### 활용 조건

- 선두 컬럼의 Distinct Value 개수가 적어야 함
- 후행 컬럼의 조건절 선택도가 좋아야 함
- 검색 대상 레코드가 소량이어야 함

#### 작동 원리

```sql
-- 인덱스: (성별, 연령, 지역)
-- 쿼리
SELECT * FROM 고객 WHERE 연령 = 30 AND 지역 = '서울';

-- Index Skip Scan 시 내부적으로 다음과 같이 처리
SELECT * FROM 고객 WHERE 성별 = 'M' AND 연령 = 30 AND 지역 = '서울'
UNION ALL
SELECT * FROM 고객 WHERE 성별 = 'F' AND 연령 = 30 AND 지역 = '서울';
```

#### 적용 시나리오

- 선두 컬럼이 BETWEEN 조건이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때
- 선두 컬럼의 변별력이 좋지 않지만 후행 컬럼들의 변별력이 좋을 때

### 3.3.8 IN 조건은 '='인가

#### IN 조건의 특성

```sql
-- IN 조건
WHERE 컬럼 IN ('A', 'B', 'C')

-- 내부적으로 OR 조건으로 변환
WHERE 컬럼 = 'A' OR 컬럼 = 'B' OR 컬럼 = 'C'
```

#### 옵티마이저 처리 방식

**IN-List Iterator 방식**

- List 개수만큼 Index Range Scan 반복
- UNION ALL 방식과 동일한 효과
- 각 값마다 수직적 탐색 수행

**OR Expansion**

- 오라클에서 use_concat 힌트로 유도 가능
- 각 조건을 별도의 실행계획으로 처리
- 결과를 UNION ALL로 결합

#### 성능 고려사항

- IN-List 개수가 적을 때는 효율적
- 개수가 많아지면 수직적 탐색 비용 증가
- 데이터 분포에 따라 성능 차이 발생

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

#### BETWEEN 조건

```sql
WHERE 날짜 BETWEEN '20220101' AND '20220131'
```

- 시작점과 끝점이 명확함
- 연속된 범위 스캔
- 중간에 멈출 수 없음

#### LIKE 조건

```sql
-- 전방 일치 검색
WHERE 상품명 LIKE '노트북%'

-- 중간 문자 포함 검색 (비효율적)
WHERE 상품명 LIKE '%노트북%'
```

**전방 일치의 장점**

- Index Range Scan 가능
- 정확한 시작점 탐색 가능
- 효율적인 스캔 범위 결정

**중간 문자 포함의 문제점**

- Index Full Scan 필요
- 시작점을 찾을 수 없음
- 전체 인덱스 스캔 후 필터링

### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

#### 문제 상황

코딩의 효율성을 위해 LIKE나 BETWEEN을 남용하면 인덱스 스캔 효율성 저하

#### 구체적 예시

```sql
-- 비효율적: 옵션 조건을 BETWEEN으로 처리
WHERE 종목코드 BETWEEN NVL(:stock_cd, '000000') AND NVL(:stock_cd, 'ZZZZZZ')
  AND 거래일자 BETWEEN :start_dt AND :end_dt
```

**문제점**

- 종목코드를 입력하지 않으면 모든 종목 데이터를 스캔
- 대량 테이블에서 매우 비효율적
- 인덱스 손익분기점을 초과할 가능성

#### 개선 방안

```sql
-- 조건부 쿼리 실행
IF :stock_cd IS NOT NULL THEN
    SELECT * FROM 테이블
    WHERE 종목코드 = :stock_cd
      AND 거래일자 BETWEEN :start_dt AND :end_dt;
ELSE
    SELECT * FROM 테이블
    WHERE 거래일자 BETWEEN :start_dt AND :end_dt;
END IF;
```

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

#### 1. OR 조건 사용

```sql
WHERE (:stock_cd IS NULL OR 종목코드 = :stock_cd)
  AND 거래일자 BETWEEN :start_dt AND :end_dt
```

**단점**

- 옵티마이저에 의한 OR Expansion이 작동하지 않을 수 있음
- 인덱스 선두 컬럼에 대한 옵션 조건에는 부적합
- 인덱스 필터 조건으로 사용 시 랜덤 액세스 후 필터링

#### 2. UNION ALL 방식

```sql
-- 종목코드 입력 시
SELECT * FROM 테이블
WHERE 종목코드 = :stock_cd
  AND 거래일자 BETWEEN :start_dt AND :end_dt
  AND :stock_cd IS NOT NULL
UNION ALL
-- 종목코드 미입력 시
SELECT * FROM 테이블
WHERE 거래일자 BETWEEN :start_dt AND :end_dt
  AND :stock_cd IS NULL;
```

**장점**

- 특정 값을 입력하든 안 하든 인덱스를 최적으로 사용
- 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용
- 가장 효율적인 처리 방식

**단점**

- SQL 코딩량이 길어짐
- 유지보수 복잡도 증가

#### 3. CASE문 활용

```sql
WHERE 종목코드 = CASE WHEN :stock_cd IS NOT NULL THEN :stock_cd ELSE 종목코드 END
  AND 거래일자 BETWEEN :start_dt AND :end_dt
```

**장점**

- UNION ALL보다 단순한 코딩
- UNION ALL과 유사한 성능

**단점**

- NULL 허용 컬럼에 사용할 수 없음
- LIKE 패턴 같은 복잡한 조건에는 부적합

#### 4. 동적 쿼리

```sql
-- PL/SQL 예시
v_sql := 'SELECT * FROM 테이블 WHERE 1=1';

IF :stock_cd IS NOT NULL THEN
    v_sql := v_sql || ' AND 종목코드 = :stock_cd';
END IF;

v_sql := v_sql || ' AND 거래일자 BETWEEN :start_dt AND :end_dt';

EXECUTE IMMEDIATE v_sql USING ...;
```

**장점**

- 조건에 따라 최적의 쿼리 생성
- 가장 효율적인 실행계획 가능

**단점**

- 개발 복잡도 증가
- 하드 파싱 증가 가능성
- SQL 인젝션 위험성

### 3.3.12 함수호출부하 해소를 위한 인덱스 구성

#### 함수 기반 인덱스 (FBI: Function-Based Index)

```sql
-- 함수 기반 인덱스 생성
CREATE INDEX idx_upper_name ON 고객(UPPER(고객명));

-- 쿼리에서 활용
SELECT * FROM 고객 WHERE UPPER(고객명) = 'KIM';
```

#### 가상 컬럼 활용

```sql
-- 가상 컬럼 추가
ALTER TABLE 주문 ADD (연월 GENERATED ALWAYS AS (SUBSTR(주문일자, 1, 6)));

-- 가상 컬럼에 인덱스 생성
CREATE INDEX idx_order_month ON 주문(연월);

-- 쿼리 최적화
SELECT * FROM 주문 WHERE 연월 = '202201';
```

#### 적용 고려사항

- 자주 사용되는 함수에만 적용
- DML 성능에 미치는 영향 고려
- 함수 결과값의 변별력 확인

---

## 3.4 인덱스 설계

### 3.4.1 인덱스 설계가 어려운 이유

#### 1. 다양한 액세스 패턴

**문제**

- 하나의 테이블에 여러 가지 조회 패턴이 존재
- 각 패턴마다 최적의 인덱스 구성이 다름
- 모든 패턴을 만족하는 단일 인덱스 설계 어려움

**예시**

```sql
-- 패턴 1: 고객별 주문 조회
SELECT * FROM 주문 WHERE 고객ID = :cust_id;

-- 패턴 2: 일자별 주문 조회
SELECT * FROM 주문 WHERE 주문일자 = :order_dt;

-- 패턴 3: 상품별 주문 조회
SELECT * FROM 주문 WHERE 상품코드 = :prod_cd;

-- 패턴 4: 복합 조건 조회
SELECT * FROM 주문
WHERE 고객ID = :cust_id
  AND 주문일자 BETWEEN :start_dt AND :end_dt;
```

#### 2. DML 성능에 미치는 영향

**인덱스 증가의 부작용**

- INSERT 성능 저하: 인덱스 개수만큼 추가 작업 발생
- UPDATE 성능 저하: 인덱스 컬럼 변경 시 인덱스 갱신 필요
- DELETE 성능 저하: 인덱스에서도 삭제 작업 수행
- 저장공간 증가: 인덱스도 물리적 저장공간 필요

#### 3. 저장공간 제약

- 인덱스 크기는 일반적으로 테이블 크기의 10~30%
- 과도한 인덱스 생성 시 저장공간 부족 문제
- 백업 시간 증가
- 유지보수 비용 상승

#### 4. 옵티마이저의 한계

- 항상 최적의 인덱스를 선택하는 것은 아님
- 통계정보의 정확성에 의존
- 복잡한 쿼리에서 잘못된 선택 가능성
- 힌트를 통한 강제 지정 필요한 경우 발생

### 3.4.2 가장 중요한 두 가지 선택 기준

#### 1. 조건절에 항상 사용되는 컬럼을 선두에 배치

**필수 조건 vs 옵션 조건**

```sql
-- 필수 조건: 항상 사용되는 조건
WHERE 고객ID = :cust_id  -- 필수

-- 옵션 조건: 경우에 따라 사용되는 조건
AND 주문일자 BETWEEN :start_dt AND :end_dt  -- 옵션
```

**설계 원칙**

- 필수 조건 컬럼을 인덱스 선두에 배치
- 변별력이 좋지 않더라도 '=' 조건 컬럼 우선
- 그로 인한 비효율을 감수해야 하는 경우도 있음

#### 2. 선택도(Selectivity)가 좋은 컬럼을 우선 배치

**선택도 계산**

```
선택도 = 1 / 컬럼의 Distinct Value 개수
```

**예시**

```sql
-- 성별 컬럼: Distinct Value = 2개
-- 선택도 = 1/2 = 0.5 (50%)

-- 고객ID 컬럼: Distinct Value = 1,000,000개
-- 선택도 = 1/1,000,000 = 0.000001 (0.0001%)
```

**우선순위**

- 선택도가 좋은(값이 작은) 컬럼을 우선 배치
- 단, 필수 조건이 우선순위가 더 높음

### 3.4.3 스캔 효율성 이외의 판단 기준

#### 1. ORDER BY 절 고려

```sql
-- 정렬이 필요한 쿼리
SELECT * FROM 주문
WHERE 고객ID = :cust_id
ORDER BY 주문일자 DESC;

-- 인덱스 구성: (고객ID, 주문일자 DESC)
-- 정렬 연산 생략 가능
```

#### 2. GROUP BY 절 고려

```sql
-- 그룹핑이 필요한 쿼리
SELECT 상품코드, SUM(주문금액)
FROM 주문
WHERE 주문일자 = :order_dt
GROUP BY 상품코드;

-- 인덱스 구성: (주문일자, 상품코드)
-- 정렬 연산 생략 가능
```

#### 3. 조인 성능 고려

```sql
-- NL 조인에서 Inner 테이블 접근
SELECT *
FROM 고객 a, 주문 b
WHERE a.고객ID = b.고객ID
  AND a.지역 = '서울';

-- 주문 테이블 인덱스: (고객ID, ...)
-- 조인 성능 최적화
```

#### 4. MIN/MAX 연산 고려

```sql
-- 최대값/최소값 조회
SELECT MAX(주문일자) FROM 주문 WHERE 고객ID = :cust_id;

-- 인덱스 구성: (고객ID, 주문일자)
-- 인덱스에서 마지막 값만 읽으면 됨
```

### 3.4.4 공식을 초월한 전략적 설계

#### 업무 중요도에 따른 우선순위

**1. 핵심 업무 우선**

```sql
-- 핵심 업무: 실시간 주문 조회 (응답속도 중요)
SELECT * FROM 주문 WHERE 고객ID = :cust_id AND 상태 = '진행중';

-- 부가 업무: 통계 조회 (정확성 중요, 속도는 차순위)
SELECT COUNT(*) FROM 주문 WHERE 주문일자 = :order_dt;
```

**인덱스 우선순위**

1. 핵심 업무용 인덱스 먼저 설계
2. 부가 업무는 기존 인덱스 활용 또는 배치 처리

#### 2. 수행 빈도 고려

- 자주 수행되는 쿼리에 인덱스 우선 할당
- 가끔 수행되는 쿼리는 기존 인덱스 활용

#### 3. 데이터 증가 패턴 고려

```sql
-- 이력성 데이터: 과거 데이터는 거의 조회하지 않음
-- 파티션 테이블 + 최신 데이터용 인덱스 집중 설계
```

#### 4. 시스템 특성 고려

- **OLTP 시스템**: 응답성 중시, 소량 데이터 처리
- **OLAP 시스템**: 처리량 중시, 대량 데이터 처리
- **배치 시스템**: 전체 처리 시간 중시

### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

#### 기본 개념

ORDER BY 절에 사용되는 컬럼을 인덱스에 포함시켜 정렬 연산을 생략

#### 적용 예시

```sql
-- 자주 사용되는 쿼리
SELECT * FROM 게시글
WHERE 게시판ID = :board_id
ORDER BY 작성일자 DESC, 글번호 DESC;

-- 최적 인덱스 구성
CREATE INDEX idx_board_sort ON 게시글(게시판ID, 작성일자 DESC, 글번호 DESC);
```

#### 고려사항

**장점**

- 정렬 연산 완전 생략
- 대량 데이터에서 극적인 성능 향상
- 메모리 사용량 감소

**단점**

- 인덱스 크기 증가
- DML 성능에 미치는 영향
- 다른 쿼리 패턴에는 비효율적일 수 있음

#### 부분 정렬 최적화

```sql
-- 상위 N개만 조회하는 경우
SELECT * FROM (
    SELECT * FROM 테이블
    WHERE 조건절
    ORDER BY 정렬컬럼
) WHERE ROWNUM <= 10;

-- 인덱스가 정렬되어 있으면 10건만 읽고 중단 가능
```

### 3.4.6 결합 인덱스 선택도

#### 선택도 계산 공식

```
결합 인덱스 선택도 = 개별 컬럼 선택도의 곱
```

#### 실제 예시

```sql
-- 테이블: 1,000,000건
-- 성별: 2개 값 (M, F) → 선택도 = 0.5
-- 연령대: 10개 값 (10대~90대) → 선택도 = 0.1
-- 지역: 50개 값 → 선택도 = 0.02

-- 결합 인덱스 (성별, 연령대, 지역) 선택도
= 0.5 × 0.1 × 0.02 = 0.001 (0.1%)
```

#### 최적 컬럼 순서 결정

```sql
-- Case 1: 모든 컬럼에 조건이 있는 경우
WHERE 성별 = 'M' AND 연령대 = '30대' AND 지역 = '서울'
-- 어떤 순서든 결과적으로 같은 효율성

-- Case 2: 일부 컬럼만 조건이 있는 경우
WHERE 성별 = 'M' AND 연령대 = '30대'
-- (성별, 연령대, 지역) vs (연령대, 성별, 지역)
-- 전자가 더 효율적 (지역 조건이 없어도 두 컬럼 모두 활용)
```

#### 설계 가이드라인

1. **선두 컬럼**: 항상 사용되는 조건 중 선택도가 가장 좋은 컬럼
2. **후속 컬럼**: 사용 빈도와 선택도를 종합 고려
3. **마지막 컬럼**: 정렬이나 GROUP BY에 사용되는 컬럼

### 3.4.7 중복 인덱스 제거

#### 완전 중복 인덱스

```sql
-- 완전히 동일한 인덱스
CREATE INDEX idx1 ON 테이블(A, B, C);
CREATE INDEX idx2 ON 테이블(A, B, C);  -- 제거 대상
```

#### 부분 중복 인덱스

```sql
-- 포함 관계에 있는 인덱스
CREATE INDEX idx1 ON 테이블(A, B, C);
CREATE INDEX idx2 ON 테이블(A);        -- 제거 고려
CREATE INDEX idx3 ON 테이블(A, B);     -- 제거 고려
```

**제거 시 고려사항**

- 더 긴 인덱스가 짧은 인덱스 역할을 완전히 대체할 수 있는가?
- 성능상 차이가 있는가?
- 유니크 제약조건 등 다른 목적이 있는가?

#### 순서가 다른 인덱스

```sql
-- 컬럼 순서가 다른 경우
CREATE INDEX idx1 ON 테이블(A, B, C);
CREATE INDEX idx2 ON 테이블(B, A, C);  -- 다른 용도로 필요할 수 있음
```

**판단 기준**

- 각각 최적화하는 쿼리 패턴이 다른가?
- 수행 빈도와 중요도는 어떤가?
- 통합 가능한 구조로 변경할 수 있는가?

### 3.4.8 인덱스 설계도 작성

#### 설계도 구성 요소

**1. 테이블별 인덱스 목록**

```
테이블명: 주문
┌─────────────────────────────────────────────┐
│ 인덱스명     │ 컬럼구성        │ 용도        │
├─────────────────────────────────────────────┤
│ PK_주문      │ 주문번호        │ 기본키      │
│ IDX_주문_01  │ 고객ID,주문일자 │ 고객별조회  │
│ IDX_주문_02  │ 상품코드,주문일자│ 상품별조회  │
│ IDX_주문_03  │ 주문일자        │ 일자별조회  │
└─────────────────────────────────────────────┘
```

**2. 각 인덱스의 대상 쿼리**

```sql
-- IDX_주문_01 (고객ID, 주문일자) 대상 쿼리들
Query_001: SELECT * FROM 주문 WHERE 고객ID = :cust_id;
Query_002: SELECT * FROM 주문 WHERE 고객ID = :cust_id
           AND 주문일자 BETWEEN :start_dt AND :end_dt;
Query_003: SELECT * FROM 주문 WHERE 고객ID = :cust_id
           ORDER BY 주문일자 DESC;
```

**3. 컬럼 순서 결정 근거**

```
IDX_주문_01 설계 근거:
- 고객ID: 필수 조건 (항상 사용됨)
- 주문일자: 범위 조건 + 정렬 용도
- 순서: 고객ID(필수) → 주문일자(정렬)
```

**4. 예상 성능 효과**

```
Query_001 개선 효과:
- 현재: Table Full Scan (500ms)
- 개선: Index Range Scan (5ms)
- 개선율: 99% 향상
```

## 실무 적용 가이드

### 단계별 인덱스 설계 프로세스

#### 1단계: 요구사항 분석

- 핵심 업무 프로세스 파악
- 주요 쿼리 패턴 수집
- 성능 요구사항 정의
- 데이터 증가 패턴 분석

#### 2단계: 기본 인덱스 설계

- 기본키, 외래키 인덱스 설계
- 필수 조건 기반 인덱스 설계
- 선택도 기반 컬럼 순서 결정

#### 3단계: 최적화 인덱스 추가

- ORDER BY 최적화 인덱스
- 조인 성능 최적화 인덱스
- 커버링 인덱스 검토

#### 4단계: 검증 및 조정

- 실행계획 검토
- 성능 테스트 수행
- DML 성능 영향 측정
- 최종 조정

### 성능 모니터링 포인트

#### 1. 인덱스 사용률 모니터링

```sql
-- 사용되지 않는 인덱스 찾기
SELECT index_name, table_name
FROM user_indexes
WHERE index_name NOT IN (
    SELECT DISTINCT index_name
    FROM v$sql_plan
    WHERE object_type = 'INDEX'
);
```

#### 2. 스캔 효율성 모니터링

```sql
-- SQL 트레이스를 통한 효율성 측정
ALTER SESSION SET SQL_TRACE = TRUE;
-- 쿼리 실행
ALTER SESSION SET SQL_TRACE = FALSE;
```

#### 3. DML 성능 모니터링

- INSERT/UPDATE/DELETE 수행 시간 측정
- 인덱스 유지보수 비용 측정
- Redo 로그 생성량 측정
