# 4.2장 소트 머지 조인

# 소트 머지 조인은 언제 사용할까?

- 조인 컬럼에 인덱스가 없을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택한다.
- 해시 조인이 더 효율적이긴 하지만, 대량 데이터를 조인할 때 유용하게 사용된다.

## 조인에서 중요한 튜닝 포인트는?

SQL이 조인을 수행할 때, 그 작업에 사용하는 메모리가 어디인지(SGA인지 PGA인지)를 이해해야 진짜 튜닝이 가능하다.

- 정렬(Sort), 해시(Hash) 작업은 → **SGA가 아닌 PGA에서 발생**
- **PGA가 부족하면 디스크 TEMP 공간을 쓰게 되어** 쿼리 성능이 급격히 저하됨

### **1. SGA & PGA**

| 항목 | SGA (Shared Global Area) | PGA (Program Global Area) |
| --- | --- | --- |
| 공유 여부 | 여러 세션이 **공유** | 세션(프로세스) **전용** |
| 주요 용도 | - SQL 파싱 결과 캐싱- 버퍼 캐시로 디스크 I/O 최소화 | - 정렬(SORT)- 해시 조인(HASH JOIN) 등 연산용 메모리 |
| 위치 | 인스턴스 메모리 | 세션별 프로세스 메모리 |
| 병목 발생 시 | SQL 재사용 안 됨, I/O 증가 | TEMP 사용으로 성능 저하 발생 |
- 소트 머지 조인과 해시 조인은 **PGA** 사용량이 많음
- SQL 튜닝 시 → `PGA_AGGREGATE_TARGET`, `WORKAREA_SIZE_POLICY` 설정도 함께 봐야 함
- **조인 방식**에 따라 병목 지점이 **SGA인지 PGA인지** 달라짐

### 2. 기본 메커니즘

1. 입력 집합 2개를 정렬 (Sort)
2. 정렬된 상태에서 병합하며 조인 (Merge)

즉, `정렬 → 병합`이라는 **2단계 프로세스**를 가진다.

### 3. 왜 빠른가?

- 정렬된 데이터의 병합(Merge)은 매우 빠른 연산
    
    → 마치 두 개의 오름차순 배열을 하나로 합치는 것과 유사
    
- 특히 양쪽 테이블이 이미 정렬되어 있다면 → 정렬을 생략하고 바로 Merge 가능
    
    → 즉, Sort 단계가 건너뛰어짐 → 성능 매우 우수
    

### 4. 해시 조인과의 차이

| 구분 | 소트 머지 조인 | 해시 조인 |
| --- | --- | --- |
| 정렬 필요 여부 | 필요 (하지만 생략 가능) | 필요 없음 |
| 성능 특징 | 정렬된 대용량 병합에 유리 | 메모리 기반 중간 해시테이블 생성에 유리 |
| 메모리 사용 | PGA (정렬 및 병합) |  |
- 해시 조인은 등치 조건일 때만 사용할 수 있다.
- 그래서 소트 머지 조인은 **등치 조건이 아니거나 조인 조건이 없는 조인**일 때 주로 사용한다.

### 5. 제어 방법

- 옵티마이저가 조인 방식 선택
    
    → 힌트로 제어 가능
    
    ```sql
    SELECT /*+ USE_MERGE(A B) */ ...
    ```
    
- 인덱스가 없거나, 인덱스 무시 힌트 사용 시 자주 선택됨

### 6. 정리: 소트 머지 조인의 특징 요약

| 항목 | 설명 |
| --- | --- |
| 조인 방식 | 정렬 후 병합 (Sort → Merge) |
| 사용 메모리 | **PGA 사용** (정렬 시) |
| 디스크 사용 위험 | PGA 부족 시 TEMP 사용 |
| 빠른 조건 | **이미 정렬된 입력**, 병합 대상이 많을 때 |
| 제어 힌트 | `USE_MERGE`, `NO_INDEX`, `ORDERED` 등 |

**소트 머지 조인은 정렬만 잘 되면 매우 빠른 조인**이다.

하지만 정렬이 필요하다는 점에서 **PGA 튜닝과 TEMP I/O에 민감**하므로 조인 방식 선택 시 메모리 구조까지 고려해야 한다.
# 4.3장 해시 조인

# 해시 조인이란

- 소트 머지 조인과 마찬가지로 인덱스를 이용하지 않는 조인이다.
- 대량의 데이터 조인할 때 NL조인보다 훨씬 빠르고, 일정한 성능을 보인다.
- 소트 머지 조인과는 다르게, 양쪽 테이블 정렬의 부담이 없다.

## 기본 메커니즘

| 단계 | 설명 |
| --- | --- |
| 1단계 | 조인 대상 중 작은 테이블(또는 선행 테이블)을 PGA에 **해시 테이블로 만든다** |
| 2단계 | 나머지 테이블을 한 줄씩 읽으며 **해시 테이블과 매칭한다** |
- 이 작업은 모두 **PGA에서 수행되며,** 메모리가 부족하면 TEMP 디스크를 사용하게 됨
- 해시 조인은 **동등 조인(=)**에서만 사용 가능

## 왜 해시 조인이 빠를까?

| 이유 | 설명 |
| --- | --- |
| 정렬이 불필요 | 소트 머지 조인과 달리 정렬 과정이 없음 → 성능 유리 |
| 인덱스 미사용 가능 | 인덱스 없어도 조인 가능 → 옵티마이저의 선택 폭이 넓음 |
| 단순한 해시 탐색 | 해시 버킷으로 한 번에 위치 확인 → 반복 검색보다 빠름 |

> 단, 전제는 해시 테이블이 메모리에 다 올라와야 한다는 것!
특히 Build 입력이 작을수록 메모리 효율도 높고 속도도 빠름
> 

**소트 머지 조인보다 빠른 이유?**

조인을 시작하기 전, 양쪽을 정렬해서 PGA에 담는 작업에서 차이난다.

- **정렬 없이** 바로 해시 테이블을 만들어서 **비교만 하기 때문에 연산 자체가 훨씬 단순**하고 빠름.
- Build Input 테이블만에 작은 집합을 저장하므로 Temp 테이블스페이스에 쓰는 작업이 거의 없다.

해시 조인은 정렬 없이 조인을 수행할 수 있고, 작은 테이블을 메모리에 올려 빠르게 탐색하기 때문에 **대용량 테이블에도 유리**한 경우가 많습니다.

특히 인덱스가 없거나, 정렬이 비효율적인 경우에 효과적이예요.

## 대용량 Build Input 처리 방식

| 상황 | 처리 방식 |
| --- | --- |
| Build Input이 메모리에 다 안 들어감 | Oracle은 **해시 테이블을 나눠서 TEMP에 저장** |
| → 파티셔닝 조인 수행 | 조인 조건별로 조각내서 **다시 해시 빌드 후 조인** |

> 이 과정을 파티셔닝 **해시 조인(partitioned hash join)**이라고 함
> 

## 실행계획 제어

| 제어 방식 | 예시 |
| --- | --- |
| 힌트 사용 | `USE_HASH(A)` : A를 Build 테이블로 해시 조인 강제 |
| 조인 순서 지정 | `ORDERED` 힌트로 선행 테이블 지정 가능 |
| 인덱스 무시 | `NO_INDEX(A)`로 인덱스 사용을 막고 해시 조인 유도 |

옵티마이저가 기본적으로 해시 조인을 선택할 수도 있지만,

우리가 USE_HASH, ORDERED, NO_INDEX 같은 힌트를 사용하면 **조인 방식과 순서를 직접 지정**할 수 있어요. 특히 튜닝 시 중요한 전략이죠.

## 옵티마이저의 조인 메소드 선택 기준

| 조건 | 선택되는 조인 방식 |
| --- | --- |
| **인덱스 존재 + 소량 데이터** | NL Join |
| **정렬 가능 + 대용량 데이터** | Sort Merge Join |
| **인덱스 없음 + 해시 조인 효율적** | Hash Join |

> 해시 조인은 동등 조건 + 인덱스 없음 + 대용량 처리에 최적화된 방식
> 

옵티마이저는 상황에 따라 자동으로 조인 방식을 결정하지만,

인덱스가 없고 조인 조건이 단순하다면 해시 조인이 가장 유력해요.

실제 실행계획을 보고 튜닝 포인트를 잡는 게 중요합니다.

## 결론

해시 조인은 **작은 테이블을 해시 테이블로 만들고 빠르게 비교**하는 방식

**→ PGA 크기, 입력 데이터 크기, 조인 조건**에 따라 성능이 크게 좌우됨
