# 4장. 조인 튜닝 - 상세 정리

## 4.1 NL 조인 (Nested Loop Join)

### 4.1.1 기본 메커니즘

#### NL 조인의 작동 원리

NL 조인은 프로그래밍에서 사용하는 중첩된 반복문과 유사한 방식으로 작동합니다.

```java
for(i=0; i<100; i++) {  // Outer 루프 (선행 테이블)
    for(j=0; j<100; j++) {  // Inner 루프 (후행 테이블)
        // 조인 처리
    }
}
```

**핵심 개념**

- **선행 테이블(Outer Table)**: 외부 루프에 해당하는 테이블
- **후행 테이블(Inner Table)**: 내부 루프에 해당하는 테이블
- 선행 테이블에서 한 건씩 읽어 후행 테이블에서 매칭되는 데이터를 찾는 방식

### 4.1.2 NL 조인 실행계획 제어

#### 힌트를 통한 제어

```sql
SELECT /*+ ORDERED USE_NL(e) */
       d.deptno, d.dname, e.empno, e.ename
FROM dept d, emp e
WHERE d.deptno = e.deptno
  AND d.loc = 'SEOUL'
  AND d.gb = '2'
  AND e.sal >= 1500
ORDER BY sal DESC;
```

**주요 힌트**

- **ORDERED**: FROM 절에 나열된 테이블 순서대로 조인
- **USE_NL(테이블명)**: 지정된 테이블을 후행 테이블로 하여 NL 조인 수행
- **LEADING(테이블명)**: 지정된 테이블을 선행 테이블로 조인 순서 결정

### 4.1.3 NL 조인 수행 과정 분석

#### 단계별 수행 과정

**1단계: 선행 테이블 처리**

- dept_loc_idx 인덱스를 스캔하여 loc = 'SEOUL' 조건 만족 레코드 탐색
- 인덱스에서 ROWID를 얻어 dept 테이블 액세스
- gb = '2' 조건으로 최종 필터링

**2단계: 후행 테이블 액세스**

- 선행 테이블에서 얻은 deptno 값으로 emp_deptno_idx 인덱스 탐색
- 인덱스에서 ROWID를 얻어 emp 테이블 액세스
- sal >= 1500 조건으로 최종 필터링

**3단계: 결과 조합**

- 조인 조건을 만족하는 레코드들을 최종 결과집합에 포함

### 4.1.4 NL 조인 튜닝 포인트

#### 첫 번째 부하지점: 선행 테이블 인덱스 스캔

```sql
-- 문제: gb='2' 조건에 의해 필터링되는 비율이 높음
-- 해결: dept_loc_idx 인덱스에 gb 컬럼 추가
CREATE INDEX dept_loc_gb_idx ON dept(loc, gb);
```

#### 두 번째 부하지점: 후행 테이블 인덱스 탐색

- 선행 테이블에서 읽은 건수만큼 인덱스 Random 액세스 발생
- 인덱스 높이(height)에 비례하여 블록 I/O 발생
- 조인 시도 횟수 최소화가 핵심

#### 세 번째 부하지점: 후행 테이블 테이블 액세스

```sql
-- 문제: sal >= 1500 조건에 의해 필터링되는 비율이 높음
-- 해결: emp_deptno_idx 인덱스에 sal 컬럼 추가
CREATE INDEX emp_deptno_sal_idx ON emp(deptno, sal);
```

### 4.1.5 NL 조인 특징 요약

#### 장점

- **소량 데이터 처리에 최적**: 부분범위 처리 가능
- **OLTP 환경에 적합**: 빠른 응답성 제공
- **인덱스 활용**: 기존 인덱스를 효과적으로 활용

#### 단점

- **인덱스 의존성**: 후행 테이블에 적절한 인덱스 필수
- **대량 데이터 처리 불리**: Random 액세스 방식으로 인한 성능 저하
- **조인 순서 중요**: 잘못된 조인 순서 시 성능 급격히 저하

#### 적용 기준

- 선행 테이블에서 추출되는 데이터가 소량일 때
- 후행 테이블 조인 컬럼에 효과적인 인덱스가 있을 때
- 부분범위 처리가 가능한 OLTP 환경

### 4.1.6 NL 조인 튜닝 실습

#### SQL 트레이스를 통한 성능 분석

```sql
-- 트레이스 활성화
ALTER SESSION SET SQL_TRACE = TRUE;

-- 쿼리 실행
SELECT /*+ ORDERED USE_NL(e) */ ...

-- 트레이스 분석 결과 확인
tkprof trace_file.trc output_file.txt
```

**분석 포인트**

- 인덱스 스캔 효율성: 스캔한 블록 수 대비 결과 건수
- 테이블 액세스 효율성: 액세스한 블록 수 대비 결과 건수
- 조인 성공률: 조인 시도 횟수 대비 성공 건수

### 4.1.7 NL 조인 확장 메커니즘

#### 테이블 Prefetch

**개념**

- 인덱스를 이용해 테이블 액세스 시 디스크 I/O가 필요하면 곧 읽을 블록까지 미리 버퍼캐시에 적재

**효과**

- 물리적 I/O 횟수 감소
- 테이블 블록 읽기 성능 향상

#### 배치 I/O (Batch I/O)

**개념**

- 디스크 I/O Call을 미뤘다가 일정 블록이 쌓이면 한꺼번에 처리
- Inner 테이블과의 조인은 나중에 일괄 처리

**특징**

- 읽는 블록마다 발생하는 I/O Call 비효율 해소
- 부분범위 처리는 정상적으로 작동
- 정렬 기준이 달라질 수 있어 ORDER BY 주의 필요

---

## 4.2 소트 머지 조인 (Sort Merge Join)

### 4.2.1 SGA vs PGA

#### SGA (System Global Area)

**특징**

- 공유 메모리 영역으로 여러 프로세스가 데이터 공유 가능
- 동시 액세스 불가로 래치(Latch) 메커니즘 필요
- DB 버퍼캐시는 SGA의 핵심 구성요소

#### PGA (Process/Program/Private Global Area)

**특징**

- 각 서버 프로세스에 할당된 독립적 메모리 영역
- 프로세스 종속적 고유 데이터 저장
- 래치 메커니즘 불필요로 SGA보다 빠른 액세스
- 공간 부족 시 Temp 테이블스페이스 활용

### 4.2.2 기본 메커니즘

#### 소트 머지 조인 2단계 처리

**1단계: 소트 단계**

- 양쪽 집합을 조인 컬럼 기준으로 정렬
- 정렬 결과를 PGA의 Sort Area에 저장 (필요시 Temp 테이블스페이스 사용)

**2단계: 머지 단계**

- 정렬된 양쪽 집합을 서로 머지하며 조인 수행

#### 상세 수행 과정

```sql
-- 예시 쿼리
SELECT /*+ ORDERED USE_MERGE(c) */
       e.사원번호, e.사원명, c.고객명, c.전화번호
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
  AND e.입사일자 >= '19960101'
  AND e.부서코드 = 'Z123'
  AND c.최종주문금액 >= 20000;
```

**1단계: 사원 테이블 정렬**

```sql
SELECT 사원번호, 사원명, 입사일자
FROM 사원
WHERE 입사일자 >= '19960101'
  AND 부서코드 = 'Z123'
ORDER BY 사원번호;  -- 조인 컬럼 기준 정렬
```

**2단계: 고객 테이블 정렬**

```sql
SELECT 고객번호, 고객명, 전화번호, 관리사원번호
FROM 고객
WHERE 최종주문금액 >= 20000
ORDER BY 관리사원번호;  -- 조인 컬럼 기준 정렬
```

**3단계: 머지 조인**

```plsql
BEGIN
    FOR outer IN (SELECT * FROM PGA_정렬된_사원)
    LOOP
        FOR inner IN (SELECT * FROM PGA_정렬된_고객
                     WHERE 관리사원번호 = outer.사원번호)
        LOOP
            -- 조인 결과 처리
        END LOOP;
    END LOOP;
END;
```

### 4.2.3 소트 머지 조인이 빠른 이유

#### NL 조인과의 차이점

**NL 조인의 특성**

- 모든 블록을 랜덤 액세스 방식으로 DB 버퍼캐시 경유
- 매번 래치 획득 및 캐시버퍼 체인 스캔 과정 필요
- 버퍼캐시에 없으면 디스크에서 읽기

**소트 머지 조인의 특성**

- 조인 대상 집합을 일괄적으로 읽어 PGA에 저장 후 조인
- PGA는 독립 공간으로 래치 획득 과정 불필요
- 같은 양의 데이터라도 SGA보다 훨씬 빠른 액세스

#### 핵심 장점

- **효율적인 탐색**: 정렬된 데이터로 조인 대상 레코드의 시작점과 끝점 파악 용이
- **인덱스 독립성**: Sort Area 데이터 자체가 인덱스 역할
- **대량 데이터 처리**: NL 조인 대비 대량 데이터 조인에서 성능 우위

### 4.2.4 소트 머지 조인의 주용도

#### 적용 상황

**1. 조인 조건식이 등치(=) 조건이 아닌 경우**

```sql
-- 범위 조건 조인
SELECT * FROM 주문 o, 고객 c
WHERE o.주문금액 BETWEEN c.최소주문금액 AND c.최대주문금액;
```

**2. 조인 조건식이 아예 없는 경우 (Cross Join, 카테시안 곱)**

```sql
-- 카테시안 곱
SELECT * FROM 상품 p, 지역 r
WHERE p.상품구분 = 'A' AND r.지역구분 = '수도권';
```

#### Cross Join 특징

- 한쪽 테이블의 모든 행과 다른 테이블의 모든 행을 조인
- 결과 개수 = 첫 번째 테이블 행 수 × 두 번째 테이블 행 수
- 대용량 테스트 데이터 생성 시 주로 활용

### 4.2.5 소트 머지 조인 제어하기

#### 힌트 사용법

```sql
-- 기본 사용법
SELECT /*+ ORDERED USE_MERGE(c) */ ...

-- 조인 순서와 함께 사용
SELECT /*+ LEADING(e c) USE_MERGE(c) */ ...
```

#### 실행계획 해석

```
MERGE JOIN
  SORT (JOIN)
    TABLE ACCESS (BY INDEX ROWID) OF '사원' TABLE
    INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
  SORT (JOIN)
    TABLE ACCESS (BY INDEX ROWID) OF '고객' TABLE
    INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

**해석**: 양쪽 테이블을 각각 소트한 후, 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 머지 조인

---

## 4.3 해시 조인 (Hash Join)

### 4.3.1 해시 조인 개념

#### NL 조인 vs 소트 머지 조인 vs 해시 조인

**각 조인 방식의 특징**

- **NL 조인**: 인덱스 이용, 인덱스 구성에 따른 성능 차이 심함, 랜덤 I/O로 대량 데이터 처리 불리
- **소트 머지 조인**: 양쪽 테이블 정렬 부담, 조인 과정에서 인덱스 미사용
- **해시 조인**: 한쪽만 해시 테이블 생성, 조인 과정에서 인덱스 미사용, 대량 데이터 조인에 빠르고 일정한 성능

### 4.3.2 해시 조인 수행 단계

#### 2단계 처리 과정

**1단계: Build 단계**

- 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵) 생성
- 조인 컬럼을 해시 함수에 입력하여 해시 체인 결정
- 해시 테이블을 PGA 영역의 Hash Area에 저장

**2단계: Probe 단계**

- 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인
- 조인 컬럼을 해시 함수에 입력하여 해당 해시 체인 탐색
- 같은 값을 찾으면 조인 성공, 없으면 조인 실패

### 4.3.3 해시 조인 상세 과정

#### Build 단계 상세

```sql
-- 사원 테이블을 읽어 해시 맵 생성
SELECT 사원번호, 사원명, 입사일자
FROM 사원
WHERE 입사일자 >= '19960101'
  AND 부서코드 = 'Z123';
```

**Build 과정**

1. 조건을 만족하는 사원 데이터를 읽음
2. 사원번호(조인 컬럼)를 해시 함수에 입력
3. 반환된 해시 값으로 해시 체인 결정
4. 해당 해시 체인에 사원 데이터 연결
5. Hash Area에 해시 테이블 저장

#### Probe 단계 상세

```sql
-- 고객 테이블을 하나씩 읽어 해시 맵 탐색
SELECT 고객번호, 고객명, 전화번호, 관리사원번호
FROM 고객
WHERE 최종주문금액 >= 20000;
```

**Probe 과정**

1. 조건을 만족하는 고객 데이터를 하나씩 읽음
2. 관리사원번호(조인 컬럼)를 해시 함수에 입력
3. 반환된 해시 값으로 해당 해시 체인 탐색
4. 같은 사원번호를 찾으면 조인 성공
5. 조인 성공한 데이터를 결과집합에 포함

### 4.3.4 해시 조인의 장점

#### 성능상 이점

**1. 메모리 효율성**

- 소트 머지 조인: 양쪽 집합 모두 정렬하여 PGA에 저장
- 해시 조인: 작은 집합만 해시 맵으로 만들어 메모리 사용량 절약

**2. 디스크 사용 최소화**

- 작은 집합을 Build Input으로 선택하므로 Temp 테이블스페이스 사용 최소화
- 인메모리(In-Memory) 해시 조인이 가능한 경우 디스크 작업 없음

**3. 일정한 성능**

- 인덱스 구성에 영향받지 않음
- 대량 데이터 조인에서 일반적으로 가장 빠른 성능

### 4.3.5 해시 조인 제어

#### 힌트 사용법

```sql
-- 기본 해시 조인
SELECT /*+ USE_HASH(c) */
       e.사원번호, c.고객명
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호;

-- 조인 순서 제어
SELECT /*+ ORDERED USE_HASH(c) */ ...

-- Build Input 직접 지정 (leading 힌트의 첫 번째 파라미터가 Build Input)
SELECT /*+ LEADING(e c) USE_HASH(c) */ ...

-- 3개 이상 테이블 조인 시 Build Input 지정
SELECT /*+ LEADING(a b c) USE_HASH(b) USE_HASH(c) SWAP_JOIN_INPUTS(c) */ ...
```

#### 실행계획 해석

```
HASH JOIN
  TABLE ACCESS (BY INDEX ROWID) OF '사원' TABLE
  INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
  TABLE ACCESS (BY INDEX ROWID) OF '고객' TABLE
  INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

### 4.3.6 해시 조인 vs 인덱스 차이점

#### 자료구조 특성

**인덱스 (NL 조인용)**

- 영구적으로 유지되는 자료구조
- 다양한 쿼리에서 공유 및 재사용
- 물리적 저장공간 필요
- 생성/유지 비용 높음

**해시 테이블**

- 단일 쿼리 전용 임시 자료구조
- 조인 완료 후 즉시 소멸
- 메모리상에만 존재 (필요시 Temp 사용)
- 생성 비용 낮지만 재사용 불가

### 4.3.7 대용량 해시 조인 처리

#### 분할 정복 방식 (Partitioned Hash Join)

**적용 조건**

- 두 테이블 모두 대용량으로 인메모리 해시 조인 불가능
- Hash Area 크기를 초과하는 경우

**처리 방식**

1. 조인하는 양쪽 집합의 조인 컬럼에 해시 함수 적용
2. 반환된 해시 값에 따라 동적 파티셔닝
3. 파티션별로 해시 조인 수행
4. 각 파티션 결과를 최종 결합

### 4.3.8 해시 조인 사용 조건

#### 필수 조건

**등치 조건 조인**

- 조인 조건식이 '=' 조건이어야 함
- 부등호, BETWEEN 등의 범위 조건에서는 사용 불가

#### 권장 조건

**OLTP 환경에서의 적용 기준**

1. **배치성 프로그램**: 대량 데이터 처리
2. **부분범위 처리 불가**: 전체 결과집합 필요
3. **인덱스 없음**: 적절한 인덱스 부재

**성능 고려사항**

- 한쪽 테이블이 작고 다른 쪽이 상대적으로 클 때 효과적
- 두 테이블 크기가 비슷한 경우에도 소트 머지 조인보다 유리
- 메모리 사용량과 임시 테이블스페이스 사용량 고려 필요

---

## 조인 방식 선택 가이드

### 상황별 최적 조인 방식

#### 소량 데이터 + OLTP 환경

- **NL 조인** 우선 고려
- 적절한 인덱스 구성 필수
- 부분범위 처리 활용 가능

#### 대량 데이터 + 등치 조건

- **해시 조인** 우선 고려
- 메모리 사용량 확인
- 배치 처리에 적합

#### 대량 데이터 + 비등치 조건

- **소트 머지 조인** 사용
- Cross Join이나 범위 조인에 활용
- 정렬 비용 고려 필요

### 튜닝 우선순위

1. **NL 조인 최적화**: OLTP 환경 1차 고려사항
2. **인덱스 구성 검토**: 조인 성능의 핵심 요소
3. **조인 순서 최적화**: 작은 집합을 선행 테이블로
4. **대안 조인 방식 검토**: NL 조인 효과 제한적일 때
5. **메모리 설정 최적화**: Sort Area, Hash Area 크기 조정

이상으로 친절한 SQL 튜닝 4장의 주요 내용을 정리했습니다. 각 조인 방식의 특성과 적용 조건을 이해하여 상황에 맞는 최적의 조인 방식을 선택하는 것이 SQL 성능 튜닝의 핵심입니다.
