# 조인 튜닝

SQL에서 **조인**(**Join**)은 실무에서 가장 빈번하게 사용되는 연산 중 하나입니다. 단순한 테이블 결합을 넘어서, 성능 최적화 관점에서는 어떤 조인 방식이 선택되었는지에 따라 쿼리 속도가 수십 배 이상 차이날 수 있습니다.

## 4.1 NL 조인

NL 조인은 중첩 반복문 방식으로 동작합니다. 외부 테이블에서 튜플을 하나씩 가져와서, 내부 테이블과 조건을 비교하여 일치하는 데이터를 찾습니다.

```sql
SELECT *
FROM A
JOIN B ON A.key = B.key;
```

위 쿼리에서 A가 outer, B가 inner라고 했을 때:

- A의 첫 번째 row → B의 모든 row 순회
- A의 두 번째 row → 다시 B의 모든 row 순회

### 실무 적용

- Index가 잘 걸린 경우, 특히 소량의 row만 추출할 때 빠릅니다.
- OLTP 시스템에서 자주 보입니다. 예: PK-FK 조인.

### 주의할 점

- Inner 쪽에 인덱스가 없으면 매우 비효율적입니다.
- 데이터 양이 많을수록 지수적으로 느려질 수 있음

### Tip

- 조인 조건 컬럼에 인덱스 강제 힌트 사용으로 효율을 높일 수 있습니다.
  - 예: USE_NL(B) 또는 INDEX(B idx_key)

## 4.2 소트머지 조인

두 테이블을 조인 키 기준으로 정렬한 후, 정렬된 데이터를 병합하면서 조인을 수행합니다. 마치 merge sort의 merge 과정과 유사합니다.

- A와 B 모두 조인 컬럼 기준으로 정렬되어 있어야 함
- 정렬된 상태에서 한 번의 scan으로 병합

### 실무 적용

- 대용량 배치 처리에 적합
- 조인 키가 이미 정렬된 상태거나 인덱스를 통해 정렬이 가능한 경우 유리

### 주의할 점

- 정렬 비용이 발생하며, 정렬을 위한 Temp 공간 사용 (I/O 부하 주의)
- 조인 조건이 범위 조건(>=, BETWEEN)이면 부적합

### Tip

- Sort-Merge Join이 발생하면 보통 쿼리 계획에서 TEMP 영역 사용량 증가
- 병렬 쿼리 + 정렬된 데이터 세트가 조합되면 좋은 성능을 낼 수 있음

## 4.3 해시 조인

먼저 한 테이블(보통 소규모)을 메모리에 로딩하고 해시 테이블을 구성한 뒤, 다른 테이블의 데이터를 하나씩 읽으면서 해시 테이블을 기준으로 매칭하는 방식입니다.

- Build input: 메모리에 해시 테이블을 만드는 쪽 (작은 테이블)
- Probe input: 해시 테이블을 탐색하면서 조인하는 쪽

### 실무 적용

- 인덱스가 없거나 정렬이 되어있지 않을 때 성능이 좋음
- 특히 DW / BI 시스템 등 대량 데이터를 조인할 때 유용

### 주의할 점

- 메모리를 많이 사용하므로, 메모리가 부족하면 성능 급감
- 히스토그램이 치우친 경우, 해시 버킷 충돌이 성능 저하로 이어짐

### Tip

- 옵티마이저가 Hash Join을 선택했다는 것은 “정렬/인덱스보다 해시가 유리하다”는 신호
- USE_HASH(B) 힌트로 강제할 수 있음

---

실무에서 중요한 건 단순히 조인 방식을 아는 것이 아니라, 내가 쿼리 튜닝을 통해 실행 계획에 어떤 영향을 줄 수 있는가입니다. 다음과 같은 힌트를 통해 조인 방식 제어가 가능합니다:

```sql
-- NL 조인 유도
SELECT /*+ USE_NL(B) */ ...

-- Hash 조인 유도
SELECT /*+ USE_HASH(B) */ ...

-- Sort-Merge 유도
SELECT /*+ USE_MERGE(B) */ ...
```
